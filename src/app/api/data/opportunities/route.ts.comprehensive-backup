import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { createEntityRecord } from '@/platform/services/entity/entityService';


import { getSecureApiContext, createErrorResponse, createSuccessResponse } from '@/platform/services/secure-api-helper';
const prisma = new PrismaClient();

export async function GET(request: NextRequest) {
  try {
    // 1. Authenticate and authorize user
    const { context, response } = await getSecureApiContext(request, {
      requireAuth: true,
      requireWorkspaceAccess: true
    });

    if (response) {
      return response; // Return error response if authentication failed
    }

    if (!context) {
      return createErrorResponse('Authentication required', 'AUTH_REQUIRED', 401);
    }

    const { searchParams } = new URL(request.url);
    const includeClosed = searchParams.get("includeClosed") === "true";

    // Use authenticated user's workspace and ID
    const workspaceId = context.workspaceId;
    const userId = context.userId;

    console.log(`üîç [DATA OPPORTUNITIES] Fetching opportunities for workspace: ${workspaceId}, userId: ${userId}, includeClosed: ${includeClosed}`);

    await prisma.$connect();

    // Build where clause for filtering
    const whereClause: any = {
      workspaceId: workspaceId,
      deletedAt: null
    };

    if (!includeClosed) {
      whereClause.status = {
        notIn: ['closed_won', 'closed_lost', 'cancelled']
      };
    }

    // Fetch opportunities from database
    const opportunities = await prisma.opportunities.findMany({
      where: whereClause,
      orderBy: {
        updatedAt: 'desc'
      },
      take: 2000 // Increased limit to prevent pagination issues
    });

    console.log(`‚úÖ [DATA OPPORTUNITIES] Found ${opportunities.length} opportunities`);

    await prisma.$disconnect();

    return createSuccessResponse(data, meta);

  } catch (error) {
    console.error('‚ùå Error fetching opportunities:', error);
    await prisma.$disconnect();
    return NextResponse.json(
      { error: 'Failed to fetch opportunities', details: error instanceof Error ? error.message : 'Unknown error' }, 
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const { workspaceId, userId, name, description, currency, estimatedValue, stage } = await request.json();

    if (!workspaceId || !userId || !name) {
      return NextResponse.json({ 
        error: "workspaceId, userId, and name are required" 
      }, { status: 400 });
    }

    console.log(`üîÑ [DATA OPPORTUNITIES] Creating opportunity: ${name} for workspace: ${workspaceId}`);

    await prisma.$connect();

    // Create entity record first (2025 best practice)
    const entityRecord = await createEntityRecord({
      type: 'opportunity',
      workspaceId: workspaceId,
      metadata: {
        name: name,
        stage: stage || 'prospecting',
        estimatedValue: estimatedValue || 0
      }
    });

    // Create new opportunity with entity_id
    const opportunity = await prisma.opportunities.create({
      data: {
        id: `opp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        entity_id: entityRecord.id, // Link to entity record
        name: name,
        description: description || '',
        currency: currency || 'USD',
        estimatedValue: estimatedValue || 0,
        stage: stage || 'prospecting',
        status: 'open',
        workspaceId: workspaceId,
        createdBy: userId,
        updatedBy: userId,
        updatedAt: new Date()
      }
    });

    console.log(`‚úÖ [DATA OPPORTUNITIES] Created opportunity: ${opportunity.id}`);

    await prisma.$disconnect();

    return createSuccessResponse(data, meta);

  } catch (error) {
    console.error('‚ùå Error creating opportunity:', error);
    await prisma.$disconnect();
    return NextResponse.json(
      { error: 'Failed to create opportunity', details: error instanceof Error ? error.message : 'Unknown error' }, 
      { status: 500 }
    );
  }
}
